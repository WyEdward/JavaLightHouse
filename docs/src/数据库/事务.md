#### 事务的原理
**一个线程在当前只能执行一个方法**
> 就是说只能串行执行，先执行完方法A才能执行方法B，如果A、B同时执行了，那就是多线程了。如果要对多线程同时操作某一方法加以限制，那就在方法前加个同步就OK了。

一个进程包含多个线程 每个线程在当前只能执行线程中的一个方法，按串行执行。
多个线程访问同一个数据库中的数据时，要对这个数据加锁，保证当前只能由一个线程获取并执行这个数据。或者对多个线程的方法加事务。

事务的本质是使用了数据库中默认自带的锁

事务是为了**解决并发问题**，是为了**解决2个线程中的方法对同一个数据库进行增删改查引发的数据抢夺问题**。

保证事务的独立性。基于锁的并发控制流程:

1. 事务根据自己对数据项进行的操作类型申请相应的锁(读申请共享锁,写申请排他锁)
2. 申请锁的请求被发送给锁管理器。锁管理器根据当前数据项是否已经有锁以及申请的和持有的锁是否冲突决定是否为该请求授予锁
3. 若锁被授予,则申请锁的事务可以继续执行;若被拒绝,则申请锁的事务将进行等待,直到锁被其他事务释放。

所以说**本质还是对数据库中的进行加锁**，synchronized 锁对象，锁方法。

#### 事务的特性(ACID)
##### 原子性、一致性、隔离性、持久性

1. 原子性(Atomicity)：每个事务(就是一件事情，包含多条sql)都是独立的事件。**要么全部执行成功，要么全部不执行**。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。
2. 一致性(Consistency)：事务的执行使数据从一个状态转换为另一个状态，但是**对于整个数据的完整性保持稳定**。
3. 隔离性(Isolation)(每个事务都是独立执行的)：隔离性使当多个用户并发访问数据库时，比如操作同一张表，数据库为每一个用户开启的事务，**不能被其他事务的操作所干扰，多个并发事务之间要相互隔离**。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要吗在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
4. 持久性（Durability）当事务正确完成之后，它**对于数据的改变是永久性**的。


#### 并发事务导致的问题
在许多事务处理同一个数据时，如果没有采取有效的隔离机制，那么并发处理数据时，会带来一些的问题。

##### 第一类丢失更新：
1、撤销一个事务时，把其他事务已提交的更新数据覆盖。
> 小明去银行柜台存钱，他的账户里原来的余额为100元，现在打算存入100元。在他存钱的过程中，银行年费扣了5元，余额只剩95元。突然他又想着这100元要用来请女朋友看电影吃饭，不打算存了。在他撤回存钱操作后，余额依然为他存钱之前的100元。所以那5块钱到底扣了谁的？

2、**脏读**：脏读时指在**一个事务处理过程里读取了另一个未提交事务的数据**
> 小明的银行卡余额里有100元。现在他打算用手机点一个外卖饮料，需要付款10元。但是这个时候，他的女朋友看中了一件衣服95元，她正在使用小明的银行卡付款。于是小明在付款的时候，程序后台读取到他的余额只有5块钱了，根本不够10元，所以系统拒绝了他的交易，告诉余额不足。但是小明的女朋友最后因为密码错误，无法进行交易。小明非常郁闷，明明银行卡里还有100元，怎么会余额不足呢？（他女朋友更郁闷。。。）

3、**幻读**也叫虚读：**一个事务执行两次查询，第二次结果集包含第一次中没有或某些行已经被删除的数据，造成两次结果不一致**，只是另一个事务在两次查询中间插入或删除了数据造成的。 幻读是事务非独立执行时发生的一种现象。
> 例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

4、不可重复读：一个事务两次读取同一行的数据，结果得到不同状态的结果，中间正好另一个事务更新了
该数据，两次结果相异，不可被信任。
> 例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。

> 不可重复读和脏读的区别：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。　

> 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是**不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数**）。

##### 第二类丢失更新
是不可重复读的特殊情况。如果**两个事物都读取同一行，然后两个都进行写操作，并提交，第一个事物所做的改变就会丢失。**
> 小明和女朋友一起去逛街。女朋友看中了一支口红，（对，女朋友就是用来表现买买买的）小明大方的掏出了自己的银行卡，告诉女朋友：亲爱的，随便刷，随便买，我坐着等你。然后小明就坐在商城座椅上玩手机，等着女朋友。这个时候，程序员的聊天群里有人推荐了一本书，小明一看，哎呀，真是本好书，还是限量发行呢，我一定更要买到。于是小明赶紧找到购买渠道，进行付款操作。而同时，小明的女朋友也在不亦乐乎的买买买，他们同时进行了一笔交易操作，但是这个时候银行系统出了问题，当他们都付款成功后，却发现，银行只扣了小明的买书钱，却没有扣去女朋友此时交易的钱。哈哈哈，小明真是太开心了！

#### 事务的隔离级别

　**事务的隔离级别有4种**，由低到高分别为**Read uncommitted** 、**Read committed** 、**Repeatable read** 、**Serializable **。而且，在事务的并发操作中可能会出现**脏读，不可重复读，幻读**。下面通过事例一一阐述它们的概念与联系。

1、Read uncommitted（最低级别，任何情况都无法保证。）
读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。

2、Read committed（可避免脏读的发生。）
Read committed！读提交，能解决脏读问题。

3、Repeatable read（可避免脏读、不可重复读的发生。）
重复读，就是在开始读取数据（事务开启）时，不再允许修改操作

4、Serializable（可避免脏读、不可重复读、幻读的发生。） 序列化
S**erializable 是最高的事务隔离级别**，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

> 大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。
> Mysql的默认隔离级别是Repeatable read。

隔离级别的设置只对当前链接有效。
对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；
对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。

**设置数据库的隔离级别一定要是在开启事务之前**。