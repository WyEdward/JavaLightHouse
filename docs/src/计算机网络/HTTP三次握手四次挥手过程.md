#### 参考链接
https://zhuanlan.zhihu.com/p/199284611
### 三次握手 四次挥手结构图
![9545_1](https://gitee.com/WyEdward/images/raw/master/img/9545_1.jpg)

![9549_1](https://gitee.com/WyEdward/images/raw/master/img/9549_1.png)

### 前言
由于 TCP 是全双工的，


TCP 进行握手初始化一个连接的目标是：**分配资源、初始化序列号**(通知 peer 对端我的初始序列号是多少)

TCP 进行断开连接的目标是：**回收资源**、**终止数据传输**。由于 TCP 是全双工的，需要 Peer 两端分别各自拆除自己通向 Peer 对端的方向的通信信道。这样需要四次挥手来分别拆除通信信道，

TCP连接的初始化序列号**不是固定的 **
#### 三次握手过程讲解
**第一次握手**
客户端向服务端发送连接请求(SYN seq = x) 表示是否可以收到我(客户端)的信息
并且告诉 Server 端我的初始序列号是 x

**第二次握手**
服务端向客户端发送响应表示(ACK = x + 1)  表示可以收到客户端的信息 知道了客户端的序列号
然后服务端向客户端发送连接请求(SYN seq = y) 表示是否可以收到我(服务端)的信息
并且告诉 客户端自己的初始序列号y

**第三次握手**
客户端回应服务端(ACK = y + 1) 表示可以收到服务端的请求信息 知道了服务端的序列号


##### 其实三次握手在特殊清况下也可以变成四次握手
当客户端与服务端同时向对方发送请求的时候

![9547_1](https://gitee.com/WyEdward/images/raw/master/img/9547_1.png)

##### 注意：
三次握手中的第二次握手其实是两步的但是因为TCP是全双工的 在连接通道的时候这两步是可以合并未一步进行的，也就是少一步就能达到连接的要求 提高了效率
但四次挥手中间的两步一般情况下是不能合并的 因为可能服务端可能还有数据传给客户端
如果客户端和服务端同时都没有数据传给对方那此时是可以合并中间两步的 也就变成了三次挥手


#### 数据传输过程讲解
1、客户端向服务端发送请求数据(seq = x + 1) 并且带上响应码 (ACK = y + 1) 表示发送数据到服务端
2、服务端收到请求 然后发送响应信息给客户端(ACK = x + 2)

#### 四次挥手过程讲解
1、客户端没有数据给服务端了 要断开自己端的通信通道了 发送断开请求(FIN seq = x + 2) 并且带上三次握手时连接的响应码(ACK = y + 1) 表示客户端与指定响应码的服务端请求断开连接   此时客户端的状态进入FIN_WAIT1
2、服务端发送响应(ACK = x + 3) 给客户端 表示收到  此时客户端的状态进入FIN_WAIT2
3、服务端也没有数据传给客户端了  就请求断开自己的通信通道 发送断开请求(FIN seq = y + 1)  
4、然后客户端回应客户端说你断开吧 此时客户端的状态进入TIME_WAIT 

##### 如果两端同时断开的话
Peer 在 FIN_WAIT1 状态下首先收到对端 Peer 的 FIN 包的话，那么该 Peer 在确认已经收到了对端 Peer 全部的 Data 数据包后，就响应一个 ACK 给对端 Peer，然后自己进入 CLOSEING 状态，Peer 在 CLOSEING 状态下收到自己的 FIN 包的 ACK 包的话，那么就进入 TIME WAIT 状态。于是，TCP 的 Peer 两端同时发起 FIN 包进行断开连接，那么两端 Peer 可能出现完全一样的状态转移 FIN_WAIT1——>CLOSEING——->TIME_WAIT，也就会 Client 和 Server 最后同时进入 TIME_WAIT 状态。同时关闭连接的状态转移如下图所示：


![9551_1](https://gitee.com/WyEdward/images/raw/master/img/9551_1.png)


进入TIME_WAIT状态是为了防止 最后发给服务端的ACK响应丢失 导致服务端没关掉

对TIME_WAIT状态的问题和解决方案？本文暂不讲述 其实是自己还不会 哈哈哈哈

##### 其实四次挥手也可以在特殊清况下变成三次挥手
当客户端与服务端同时都没有数据传給对方的时候  
上述的第2步和第3步可以 合并 成为一步
      