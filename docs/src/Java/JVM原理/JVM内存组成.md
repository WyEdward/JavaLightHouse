### JVM内存组成
内存可以分为** 程序计数器**、**java虚拟机栈**、**本地方法栈**、**java堆**、**方法区**、**运行时常量区**。
![](https://gitee.com/WyEdward/images/raw/master/img/运行时数据区图.png)


#### 程序计数器
程序计数器主要是记录当前线程运行的方法字节码地址  可以理解为行号它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能 它属于线程私有
每个线程都有一个程序计数器
#### java虚拟机栈
java虚拟机栈主要是**当前线程每运行一次方法就创建一个栈帧**（这个**栈帧用来存储方法的局部变量、操作数栈、动态链接、方法出口**）然后将这个栈帧推到栈里面。也属于线程私有
局部变量表存放了编译期可知的各种java虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型），它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和**returnAddress类型**（**指向了上一条字节码指令的地址**）。
它也属于线程私有 每个线程都有一个虚拟机栈
#### 本地方法栈
本地方法栈其实是和java虚拟机栈是一样的，主要调用本地的方法。本地方法是有native修饰的，一般是c或c++的程序
#### java堆
java堆是内存区域最大的一块，主要负责**对象实例的存储**。属于公共区域
对象创建是看**java堆内存分配是否规整（看虚拟机有没有空间压缩的能力） **
> 如果是规整的话，那对象内存分配是“**指针碰撞**”也就是把堆划分为分配好的内存和为分配的内存 中间有条指针，然后分配内存的时候，指针向右移动和对象分配内存大小的距离。 
>
> > 如果不是规整的话，就使用“**空闲列表**”来划分，就是虚拟机就必须维护一个列表，记录上那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配的方式称为“空闲列表”（Free List）

 对象创建完之后、除了对象头里面的数据，其余数据都置零
  对象包含**对象头**、**实例数据**、**对齐填充**
>**对象头**包含**Mark word(运行时数据)、类型指针、数组长度（如果是数组对象）**
>>**实例数据**就是我们程序代码的数据 什么变量。
>>
>>>**对齐填充**，是我们的数据至少是8字节的倍数 用来凑字节数的。

对象头的一部分是**运行时数据**
> 存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32为和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称为“Mark Word”

对象头的另外一部分是**类型指针**，
>即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。


除如何划分可用空间之外，还有另外一个需要考虑的问题：对**象创建在虚拟机中是非常频繁的的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来的及修改，对象B又同时使用了原来的指针来分配内存的情况**。

解决这个问题有两种可选方案：

一种是对分配内存的动作进行同步处理-实际上虚拟机时采用**CAS配上失败重试的方式保证更新操作的原子性**；

另外一种时把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓存**（Thread Local Allocation Buffer, TLAB),哪个线程要分配内存，就在哪个线程的本地缓存区中分配，只有本地缓冲区用完了，分配新的缓存时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。
    内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺遍进行。这步操作保证了对象的实例字段能够在Java代码中可以不赋初始值就直接使用，是程序能访问这些字段的数据类型所对应的零值。

对象的访问包括**句柄访问**和**指针访问**，首先java虚拟机栈和本地方法栈中存着局部变量表里面有一个reference对象，可能指向java堆句柄池的地址、也可能直接指向java堆中对象的地址。

> 假如使用句柄访问、java堆中就要被划分出一个句柄池，然后指向实例数据和实例类型，**实例数据类型是存放在方法区中的** 所以句柄池指向实例池和方法区。

> 假如直接访问 就省掉了中间步骤 速度更快，java对象头有类型指针，所以**指向方法区中的类型数据。**


如果使用句柄访问的话，Java堆中将可能回划分出一块内存来作为句柄池，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。


这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象时非常普便的行为）时只会改变句柄的实例数据指针，而reference本身不需要被修改。
    
使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机HotSpot而言，它主要使用第二种方式进行对象访问（有例外情况，如果使用了Shenandoah收集器的话也会有一次额外的转发，具体可参见第3章），但从整个软件开发的范围来看，在各种语言、框架中使用句柄来访问的情况也十分常见。

#### 方法区
方法区跟java堆一样也属于公共区域。**以前的方法区是永久代，但现在没有永久代这个概念** **元空间**，是用永久代实现了方法区而已。**方法区本质是java堆中的，但是与java堆分出来了**，方法区是个线程共享的内存区域，它用于**存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存**等数据。
   ** 方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。主要就是类的一些信息和字段**。

#### 运行时常量池
6、运行时常量池
运行时常量池就是方法区中的一部分。用来存储Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table）用于存放编译期生成的各种字面量与符号饮用，这部分内容将在类加载后存放到方法区的运行时常量池中。

程序计数器不会出现oom异常（内存溢出）